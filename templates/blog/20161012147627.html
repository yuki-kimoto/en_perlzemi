<ol class = "bread" itemscope itemtype = "http://schema.org/BreadcrumbList">  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">    <a itemprop="item" href="/">        <span itemprop = "name">Perl </span></a>
    <meta itemprop = "position" content = "1" />
  </li>
  &#8250;
  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">      <span itemprop = "name">here </span>
    <meta itemprop = "position" content = "2" />
  </li>
</ol>
<h2> Let's understand Perl arrays </h2>



An array is a variable that can store multiple values. Use arrays when you need to work with multiple pieces of the same type of data. Perl arrays are useful because they are called dynamic arrays and automatically grow in size.

<h3> Array basics </h3>

I will explain the basics of arrays.

<ul>
  <li>
    Array declaration
  </li>
  <li>
    Initialize
  </li>
  <li>
    Element reference
  </li>
  <li>
    Assignment to element
  </li>
  <li>
    Number of arrays
  </li>
  <li>
    Iterative processing
  </li>
</ul>

<h4> Array declaration </h4>

Use my to declare an array as you would for a scalar variable. Prefix with @(at sign) to represent the array.

<pre>
my @numbers;
</pre>

<h4> Array initialization </h4>

You can assign data representing multiple values ​​called <a href="/blog/20100308126967.html">list</a> to the array. The list is

<pre>
(Value 1, Value 2, Value 3)
</pre>

It is expressed using () like.

To assign a list to an array:
<pre>
@numbers = (10, 25, 40, 4, -6);
</pre>

You can also declare and assign an array at the same time.

<pre>
my @numbers = (10, 25, 40, 4, -6);
</pre>

<h4> Array element reference </h4>

To reference the elements of an array: Note that the first character is $, not @. Subscripts start at 0.

<pre>
$Array[subscript]
</pre>

You can output the first element and the second element as follows:

<pre>
print $numbers[0];
print $numbers[1];
</pre>

<h4> Array element assignment </h4>

To make an assignment:

<pre>
$Array[subscript] = value
</pre>

Try substituting 20 for the first element.

<pre>
$numbers[0] = 20;
</pre>

<h4> Number of elements in the array </h4>

To get the number of arrays, evaluate the arrays in a scalar context. I'll explain the scalar context elsewhere, but remember that you can get the number of arrays by assigning an array to a scalar variable at first.

<pre>
my $cnt = @nums;
</pre>

See the following article for a detailed explanation of how to get the number of elements in an array.

<ul>
  <li>
    <a href="/blog/20180604152811.html">Get the number of elements in the array</a>
  </li>
</ul>

<h4> Process the elements of the array in order </h4>

Use a for or foreach statement to process the elements of an array in sequence. For is used when you want to access in order using subscripts, and foreach is used when you simply want to process arrays in order. It's a good practice in Perl to use for when foreach can't handle it.
Let's output the elements of the array in order with the for statement.

<pre>
for (my $i = 0; $i <@nums; $i++) {
  print $nums[$i], "\n";
}
</pre>

Let's output the elements of the array in order with the foreach statement.

<pre>
foreach my $num (@nums) {
  print $num, "\n";
}
</pre>

<h3> Manipulation of array elements </h3>

You can use functions to add and retrieve elements from the array.

<ul>
  <li>
    shift function
  </li>
  <li>
    unshift function
  </li>
  <li>
    pop function
  </li>
  <li>
    push function
  </li>
</ul>

<h4> shift function </h4>

You can use the "shift function" to "get the first element" of an array. If @array was (1, 2, 3), 1 would be assigned to $first and @array would be (2, 3).

<pre>
my $first = shift @array;
</pre>

<ul>
  <li>
    <a href="/blog/20100104126425.html">shift function</a>
  </li>
</ul>

<h4> unshift function </h4>

You can use the "unshift function" to "add an element to the beginning" of an array. If @array was (1, 2, 3) then @array would be (5, 1, 2, 3).

<pre>
unshift @array, 5;
</pre>

<ul>
  <li>
    <a href="/blog/20100105126425.html">unshift function</a>
  </li>
</ul>

<h4> pop function </h4>

You can use the "pop function" to "extract the last element" of an array. If @array is (1, 2, 3), 3 is assigned to $last and @array becomes (1, 2).

<pre>
my $last = pop @array;
</pre>

<ul>
  <li>
    <a href="/blog/20100106126425.html">pop function</a>
  </li>
</ul>

<h4> push function </h4>

You can use the "push function" to "add an element to the end" of an array. .. If @array was (1, 2, 3) then @array would be (1, 2, 3, 5).

<pre>
push @array, 5;
</pre>

<ul>
  <li>
    <a href="/blog/20100107126425.html">push function</a>
  </li>
</ul>

<h3> Sorting the array </h3>

Use the sort function to sort the array.

<h4> sort function </h4>

Pass a code block for comparison as the first argument. To sort in ascending order, write $a before $b, and to sort in descending order, write $b before $a. Use <=> as the comparison operator if you want to compare as a number, and use cmp if you want to compare in lexicographical order.

<pre>
# Sort in ascending order
@sorted = sort {$a operator $b} @array;

# Sort in descending order
@sorted = sort {$b operator $a} @array;
</pre>

Let's sort the numbers in ascending order. @nums becomes (2, 3, 5, 8).

<pre>
# Sort by numerical value in ascending order
my @nums = (5, 8, 3, 2);
@nums = sort {$a <=> $b} @nums;
</pre>

<ul>
  <li>
    <a href="/blog/20100110126528.html">sort function</a>
  </li>
</ul>

<h4> Easily sort in reverse order </h4>

You can also use the "reverse function" if you want to easily sort in reverse order.

<pre>
@reverse = reverse @elements;
</pre>

<ul>
  <li>
    <a href="/blog/20080227120413.html">reverse function</a>
  </li>
</ul>

<h3> Array reference </h3>

<span style = "font-weight: bold;">A reference is the location of the memory that contains the array </span>. If you know C language, think of it as a "pointer that cannot perform address arithmetic". If you know Java, think of it as a "reference".

<h4> Creating an array reference </h4>

<pre>
my $numbers_ref1 = \@numbers;
</pre>

<span style = "font-weight: bold;">You can create an array reference by prefixing @with \.

<h4> Create a direct array reference </h4>

<pre>
my $numbers_ref2 = [1, 2, 3, 4];
</pre>

<span style = "font-weight: bold;">Enclose the list in [] to serve as an array reference. </span>

<h4> Array element reference </h4>

<pre>
$numbers_ref2->[0]
</pre>

<span style = "font-weight: bold;">Array reference->[element number] </span>

<h3> Comparison of arrays and array references </h3>

I compared the array and the array reference. It's easy to misunderstand, so let's get a better understanding of the difference between the two.

<h4> Element reference </h4>

<pre>
# arrangement
$numbers[0]

# Array reference
$numbers_ref->[0]
</pre>

<h4> Array reference dereference </h4>

<pre>
@$numbers_ref
</pre>

Dereference when you want to return to an array such as a for statement or a function that takes an array as an argument

Array references are also explained in detail on the following pages.

<ul>
  <li>
    <a href="/blog/20180214151861.html">Array reference</a>
  </li>
</ul>

<h3> List </h3>

A <strong> list </strong> is a representation of a sequence of multiple values. Lists and arrays are different. Lists are notations, while arrays are variables.

<pre>
# List
('a', case:

  break; b', 'c', 'd')
</pre>

Lists can be assigned to arrays.

<pre>
# Assignment to array
my @array = ('a', 'b', 'c', 'd');
</pre>

RiSee <a href="/blog/20100308126967.html">List-A list of multiple values ​​</a> for more information on strikes.

<h3> Functions/syntax/operators related to arrays </h3>

<h4> splice function </h4>

Use the <strong> splice function </strong> to perform complex operations on <strong> array elements </strong>. You can retrieve and replace multiple elements. If $length is omitted when fetching multiple elements, the target is from the position of $pos to the end of the array.

<pre>
# Extraction of multiple elements
@parts = splice @array, $pos, $length;

# Multi-element replacement
splice @array, $pos, $length, @replace;
</pre>

<ul>
  <li>
    <a href="/blog/20080127120141.html">splice function</a>
  </li>
</ul>

<h4> grep function </h4>

You can use the "<strong> grep function </strong>" to retrieve only the elements that match the conditions in the array. Each element of @array is passed to the default argument $_. Only elements that meet the conditional statement will be added to @matched.

<pre>
# Extract only the elements that match the conditions
@matched = grep {conditional statement} @array;
</pre>

<ul>
  <li>
    <a href="/blog/20100119126425.html">grep function</a>
  </li>
</ul>

<h4> map function </h4>

Use the <strong> map function </strong> to convert all the elements of a <strong> array </strong>. Each element of @array is passed to the default variable $_, so perform the necessary conversions in the code block {}. The last evaluated conversion statement is added to @mapped in order.

<pre>
# Conversion of all elements of the array
@mapped = map {conversion} @array;
</pre>

<ul>
  <li>
    <a href="/blog/20100118126425.html">map function</a>
  </li>
</ul>

<h4> String list operator </h4>

There is an operator called the <strong> string list operator </strong> to concisely describe a list of strings. You can use the string list operator to represent a list of strings without writing single quotes or commas.

<pre>
qw (string 1 string 2 string 3)
</pre>

This is an example of actually using the string list operator.

<pre>
my @strings = qw/cat dog mouse/;
</pre>

It has the same meaning as the following list of strings.

<pre>
my @strings = ('cat', 'dog', 'mouse');
</pre>

<ul>
  <li>
    <a href="/blog/20080222120369.html">Operator Dictionary-String list operator "qw"</a>
  </li>
</ul>

<h4> Array slice </h4>

To retrieve multiple elements by specifying the element number from the array, use a technique called <strong> array slice </strong>.

<pre>
# Array slice
my @values ​​= @array ['m', 'n', ...]
</pre>

<ul>
  <li>
    <a href="/blog/20080216120316.html">Syntax Dictionary-Array Slice</a>
  </li>
</ul>

<h3> "Multidimensional data structure" that combines arrays and hashes </h3>

Understanding "multidimensional data structures" that combine "arrays", "hashes" and "references" is essential to becoming an intermediate player.

<pre>
# Hash array
my $people = [
  {name =>'Kimoto', age => 36},
  {name =>'Tanaka', age => 20}
]
</pre>

The "multidimensional data structure" is explained in detail in the next article, so please refer to it.

<div class = "icon-arrow">"<a href="/blog/20100930127859.html">Perl's" arrays "and" hashes "are free to manipulate" multidimensional data structures "</a>" </div>

<h3> Sample program </h3>

<h4> Search for elements in an array, remove duplicate elements in an array, count duplicates </h4>

This is a sample to search for elements in an array, remove duplicate elements in an array, and count duplicates.

<pre>
use strict;
use warnings;

my @numbers = (1, 2, 3, 3, 4, 5, 6, 6, 6, 7, 8);
print'array: @numbers = ('. join(',', @numbers). ")\n\n";

# 1: Check if the array contains the specified element.
Apply # grep.
my $saerch_number = 3;
if (grep {$_ == $saerch_number} @numbers) {
  # If the element to be searched is found, the inside of the if statement will be true.
  print "1: $saerch_number exists.\n";
}

# 2: Remove duplicates from array (order is not guaranteed)
The # hash key has the property of not allowing duplication.
my %no_duplicate_hash;
for my $number (@numbers) {
  $no_duplicate_hash{$number} ++;
}

# Get a list of hash keys
my @no_duplicate_numbers = keys %no_duplicate_hash;
print '2: @no_duplicate_numbers = ('. join(',', @no_duplicate_numbers). ")\n\n";

# 3: Count the number of overlapping elements in the array (continued above)
print "3: Number of elements\n";
for my $key (sort keys %no_duplicate_hash) {
  print "$key contains $no_duplicate_hash{$key}.\n";
}
</pre>

<h4> Array reference </h4>

This is a sample program for array reference, array conversion, and element reference.

<pre>
use strict;
use warnings;

my @numbers = (1, 2, 3, 4, 5, 6, 7, 8);
print "array: \@numbers =", join(',', @numbers). ")\n\n";

# 1: Array reference If you put\before @, it becomes an array reference.
my $numbers_ref1 = \@numbers;

You can revert to the original array by prefixing the # array reference with @.
# This is called a dereference.
print "array: \@\$numbers_ref1 =" .join(',', @$numbers_ref1), ")\n";

# 2: However, I usually don't write it like the above.
# Make a direct array reference using something called an anonymous array ([]).
my $numbers_ref2 = [1, 2, 3, 4];
print "array: \$numbers_ref2 =", join(',', @$numbers_ref2). "]\n\n";

# 3: Access the elements of the array. ($array_ref->[element number])
print "\$numbers_ref2->[0] = $numbers_ref2->[0]\n";
print "\$numbers_ref2->[1] = $numbers_ref2->[1]\n";
</pre>

Execution result
<pre>
Array: @numbers = (1,2,3,4,5,6,7,8)

Array: @$numbers_ref1 = (1,2,3,4,5,6,7,8)
Array: $numbers_ref2 = [1,2,3,4]

$numbers_ref2->[0] = 1
$numbers_ref2->[1] = 2
</pre>

<h4> Sample of array and array reference comparison </h4>

This is a sample program that allows you to see how arrays and array references differ.

<pre>
use strict;
use warnings;

my @numbers = (1, 2, 3);
print "array: \@numbers =", join(',', @numbers), ")\n\n";

my $numbers_ref = [1, 2, 3];

# 1. Element reference
print "1. Element reference\n";
print "\$numbers[0] =", $numbers[0], "\n";

# Array reference
print "\$numbers_ref->[0] =", $numbers_ref->[0], "\n";
print "\n";

# 2. Processing of each element
print "2. Processing of each element\n";

# arrangement
print "\@numbers =";
for my $number (@numbers) {
  print $number. ", ";
}
print "\n";

# Array reference (dereference it to the for statement)
print "\@{\$numbers_ref} =";
for my $number (@$numbers_ref) {
  print $number. ", "
}
print "\n\n";

# 3. How to use the function
print "3. How to use the function\n";

# arrangement
push @numbers, 4;
@numbers = sort {$b <=> $a} @numbers;
print "\@numbers = (", join(',', @numbers), ")\n";

# Array reference (dereference and pass to function)
push @$numbers_ref, 4;

The # sort function returns an array, so use an anonymous array []
# Recreating an array reference.
$numbers_ref = [sort {$b <=> $a} @$numbers_ref];
print "\@\$numbers_ref =", join(',', @$numbers_ref), ")\n\n";
</pre>

Execution result

<pre>
Array: @numbers = (1,2,3)

1. Element reference
$numbers[0] = 1
$numbers_ref->[0] = 1

2. Processing of each element
@numbers = 1,2,3,
@{$numbers_ref} = 1,2,3,

3. How to use the function
@numbers = (4,3,2,1)
@$numbers_ref = (4,3,2,1)
</pre>

<h3> Column "Perl that incorporates dynamic arrays into language features" </h3>

Arrays that are built into Perl as a language feature are called dynamic arrays because you can freely add and remove values.

Perl has made a great decision to incorporate dynamic arrays into the language as a language feature. It's a very useful idea to handle arrays freely. This was a huge success, with most later scripting languages incorporating dynamic arrays into their languages.

Perl, a treasure trove of ideas created by linguist Larry Wall, is still alive.