<ol class = "bread" itemscope itemtype = "http://schema.org/BreadcrumbList">
  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
    <a itemprop="item" href="/">
        <span itemprop = "name"> Perl </span></a>
    <meta itemprop = "position" content = "1" />
  </li>
  &#8250;
  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
    <a itemprop="item" href="/blog/20161004147558.html">
      <span itemprop = "name"> standard function </span></a>
    <meta itemprop = "position" content = "2" />
  </li>
  &#8250;
  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
    here
  </li>
</ol>
<h2> undef function - undefined value </h2>



You can use the <strong> undef function </strong> to set a <strong> undefined value </strong>. Alternatively, undefine the value of the variable specified in the argument.

<pre>
undef
undef(variable)
</pre>

Set the undefined value as follows. The value of the variable "$name" becomes undefined.

<pre>
$name = "Kimoto";
$name = undef;
</pre>

You can also undefine the value of a variable by passing the variable as an argument of the undef function as follows.

<pre>
$name = "Kimoto";
undef $name;
</pre>

You can also use the undef function for arrays and hashes.

<pre>
@names = undef;
undef @names;

% scores = undef;
undef %score;
</pre>

<h3> Judgment of undefined value </h3>

You can use the <a href="/blog/20100219126425.html"> defined function</a> to determine if it is an undefined value. Returns true if defined, false if undefined.

<pre>
if (defined $name) {
  ...
}
</pre>

It's also a good idea to write using unless to handle cases where the value is undefined.

<pre>
unless (defined $name) {
  # What to do if undefined
}
</pre>

<h3> Comparison with undefined value </h3>

undef is treated as an "empty string" when compared as a string and as "0" when compared as a number.

<pre>
undef == 0
undef eq ""
</pre>

If you use <a href="/blog/20130916137930.html"> warnings module</a>, it will warn you in such a case and prevent bugs, so be sure to declare it.

<pre>
use warnings;
</pre>

<h3> Memory release using undef </h3>

Assigning undef frees the memory.

However, in Perl, lexical variables automatically free memory at the end of scope, so you're unlikely to have a chance to use undef to free memory.

<pre>
{
  my $num = 5;
}
# At the end of scope, "$num" memory is freed
</pre>

However, even after the scope ends, the memory may not be released due to closures. In such cases, you can explicitly use undef to free memory.

Please refer to the following articles for closures.

<ul>
  <li>
    <a href="/blog/20080710121570.html"> Closure</a>
  </li>
</ul>

<h3> Sample </h3>

This is a sample undef function that you can run and try.

<pre>
use strict;
use warnings;

# Set undefined value for variable
my $name = "Kimoto";
$name = undef;

if (defined $name) {
  print "Defined";
}
else {
  print "Undef";
}
</pre>