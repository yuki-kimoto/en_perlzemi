<ol class = "bread" itemscope itemtype = "http://schema.org/BreadcrumbList">
  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
    <a itemprop="item" href="/">
        <span itemprop = "name"> Perl </span></a>
    <meta itemprop = "position" content = "1" />
  </li>
  &#8250;
  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
    <a itemprop="item" href="/blog/20161004147558.html">
      <span itemprop = "name"> standard function </span></a>
    <meta itemprop = "position" content = "2" />
  </li>
  &#8250;
  <li>
    here
  </li>
</ol>
<h2> index function - string search </h2>

You can use the <strong> index function </strong> to search for <a href="/blog/20161003147558.html"> strings</a>.

In the first argument, specify the character string to be searched, and in the second argument, specify the character string you want to search. You can specify the search start position in the third argument. If omitted, the search will be performed from the beginning of the character string. If found, that position is returned, otherwise -1 is returned.

<pre>
my $pos = index($target, $str);
</pre>

<h4> Search for the character that appears the second time </h4>

<pre>
my $word_love_pos_second
  = index($message, 'love', $word_love_pos_first + 1);
</pre>

The search start position can be specified in the third argument of index. In the first search, specify the position next to the found position.

<h4> Get all positions of the searched character </h4>

<pre>
{
  my @found_positions = ();
  my $found_posision = -1;
    
  while (1) {
    $found_posision = index($message,'love', $found_posision + 1);
    last if $found_posision == -1;
    push @found_positions, $found_posision;
  }
    
  print "Founded positions:" . join(',', @found_positions) . "\n";
}
</pre>

In <a href="/blog/20100123126425.html"> while statement</a>, repeat the index function until the return value becomes -1.

<h4> If you want to handle Japanese </h4>

In order for the index function to handle Japanese correctly, the character string must be an internal character string. See the following articles for internal strings.

<ul>
  <li>
    <a href="/blog/20091118124667.html"> Encode module-Properly handles multi-byte character strings such as Japanese</a>
  </li>
</ul>

<h4> Search by regular expression </h4>

You can also search for strings using <a href="/blog/20100827127859.html"> regular expressions</a>. If you want to specify the target string instead of the character position, use a regular expression.

<pre>
# Use regular expressions to find out if Ken exists
my $message = "I'm Ken";
if ($message =~ /Ken/) {
  ...
}
</pre>

<h3> Programming sample using index function </h3>

This is a sample to check the first position of the comma using the index function.

<pre>
# Find out the first position of the comma
my $csv = 'aaa,bbb,ccc';
my $pos = index($csv, ',');
</pre>

This is a sample that processes only when a character string is found.

<pre>
# Process only if the string is found
my $string = "I'm Ken";
my $search = 'Ken';

if (index($string, $search)! = -1) {
  print "Found\n";
}
</pre>

Other samples.

<pre>
use strict;
use warnings;

my $message = "love love love.";

# Search for characters using the index function
my $word_love_pos_first = index($message,'love');

# Search for the second love
my $word_love_pos_second = index($message,'love', $word_love_pos_first + 1);

print "First: $word_love_pos_first, Second: $word_love_pos_second\n";

# Repeated search
{
  my @found_positions = ();
  my $found_posision = -1;
    
  while (1) {
    $found_posision = index($message, 'love', $found_posision + 1);
    last if $found_posision == -1;
    push @found_positions, $found_posision;
  }

  print "Found:" . join(',', @found_positions) . "\n";
}
</pre>

Output result

<pre>
First: 0,Second: 5
Found: 0,5,10
</pre>
