<script> location.href = "https://mojolicious.perlzemi.com/blog/20101128129876.html"; </ script>
<ol class = "bread" itemscope itemtype = "http://schema.org/BreadcrumbList">
  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
    <a itemprop="item" href="/">
      <span itemprop = "name"> Perl </ span>
    </a>
    <meta itemprop = "position" content = "1" />
  </ li>
  & # 8250;
  <li itemprop = "itemListElement" itemscope itemtype = "http://schema.org/ListItem">
    <a itemprop="item" href="/blog/20140319139520.html">
      <span itemprop = "name"> Mojolicious </ span>
    </a>
    <meta itemprop = "position" content = "2" />
  </ li>
</ ol>
<h2> Technique to freely generate "URL" with Mojolicious </ h2>




<h3> Basics for creating URLs </ h3>

You can specify the URL using <strong> url_for </ strong>. Mojolicious can be executed in multiple environments such as CGI and embedded web server, but if you describe the URL with the url_for method, you can describe the URL that can be executed in any environment.

<pre>
url_for ('/ user / register');
</ pre>

Also, what you can do by passing the root name is that you can restore the parameters contained in the URL. vinegar.

<pre>
get'/ foo / bar /: id';

url_for ('foobarid', id => 3);
</ pre>

<h3> Mojolicious generates a URL containing a query string </ h3>

Use the <strong> query </ strong> method to generate a URL containing a query string in Mojolicious.

<pre>
<% = url_for ('/ path')-> query (foo =>'a', bar =>'b')%>;
</ pre>

<h3> Restore request URL </ h3>

To restore the request URL, specify nothing in the argument of the url_for method or specify <strong> current </ strong>.

<pre>
% my $ url = url_for;
% my $ url = url_for ('current');
</ pre>

URLs captured with a description such as ": id" will also be restored correctly.

<pre>
/ entry /: id
</ pre>

However, the part of the query string is not automatically restored, so if you want to restore it, you need to use <strong> url_with </ strong>.

<pre>
% my $ url = url_with;
</ pre>

<pre>
% $ url-> query ([name =>'Ken', age => '19']);
</ pre>

In this way, you can easily describe a narrower search for the search conditions.

Also, if the query method sets the value, you can write it in one line as follows, remembering that it returns its own Mojo :: URL object.

<pre>
% = url_with-> query ([name =>'Ken', age => '19']);
</ pre>

<h3> Handling query strings </ h3>

If you want to parse the query string, use the parse method of Mojo :: Parameters.

<pre>
$ params-> parse ('foo = b% 3Bar & baz = 23');
</ pre>

As a general usage, after creating a Mojo :: URL object with the url_for method, you will often use the parse method after getting the Mojo :: Parameters object with the query method of the Mojo :: URL.

You can set the query string in the URL as follows.

<pre>
#In the template
% my $ url = url_for ('/ search');
% $ url-> query-> parse ('title = perl & name = ken');
</ pre>

<h4> Replace query string </ h4>

To replace the query string, pass it in list format as follows:

<pre>
$ url-> query (name =>'taro', price => 1900);
</ pre>

In the case of the above example, it is replaced as follows.

<pre>
# Previous
title = perl & name = ken

# After
name = taro & price = 1900
</ pre>

<h4> Merge query strings </ h4>

To merge the query strings, pass it as an array reference.
<pre>
$ url-> query ([name =>'taro', price => 1900]);
</ pre>

It will be merged as follows: Those with the same value will be replaced.

<pre>
# Previous
title = perl & name = ken

# After
title = perl & name = taro & price = 1900
</ pre>

<h4> Add query string </ h4>

Pass it as a hash reference to add the query string.
<pre>
$ url-> query ({name =>'taro', price => 1900});
</ pre>

It will be added as follows.

<pre>
# Previous
title = perl & name = ken

# After
title = perl & name = ken & name = taro & price = 1900
</ pre>

<h3> Generate a URL that inherits the query string of the request --url_with </ h3>

For example, you often want to change only the page number without changing the search criteria. You want to use the query string part as it is, but you want to change some conditions.

In such cases, use the <strong >> url_with </ strong> helper. The usage is the same as url_for except that it inherits the query string.

<pre>
% = url_with'/ foo'
</ pre>

You can change only the page number by writing as follows.

<pre>
% = url_with-> query ([page => 2])
</ pre>

<h3> Make sure that the host name, port number, and path are correctly recognized when using a reverse proxy </ h3>

When using a web server such as Apache as a reverse proxy and dispatching it to a Mojolicious application, redirecto_to, which outputs an absolute URL with the same settings, does not output the URL correctly. For example, suppose you make the following settings.

<pre>
  <VirtualHost *: 80>
    ServerName perlcodesample.com
    <Proxy *>
      Order deny, allow
      Allow from all
    </ Proxy>
    ProxyRequests Off
    ProxyPreserveHost On

    ProxyPass / gitweblite http: // localhost: 10010 / gitweblite keepalive = On
    ProxyPassReverse / gitweblite http: // localhost: 10010 / gitweblite

    RequestHeader set X-Forwarded-Proto "https"
  </ VirtualHost>
</ pre>

Please note that recent Linux has selinux enabled, but when this is enabled it becomes "Service Temporarily Unavailable" and Apache cannot connect to the application. Change the setting or disable selinux.

<pre>
# / etc / selinux / config
SELINUX = disabled
</ pre>

<h4> How to recognize correctly </ h4>

Let's add the following description.

<pre>
#Application class
sub starup {
  my $ self = shift;
  
  #Reverse proxy support
  $ ENV {MOJO_REVERSE_PROXY} = 1;
  $ self-> hook ('before_dispatch' => sub {
    my $ self = shift;
    
    if ($ self-> req-> headers-> header ('X-Forwarded-Host')) {
      my $ prefix = shift @ {$ self-> req-> url-> path-> parts};
      push @ {$ self-> req-> url-> base-> path-> parts}, $ prefix;
    }
  });
}
</ pre>

<h4> MOJO_REVERSE_PROXY settings </ h4>

The environment variable MOJO_REVERSE_PROXY must be set to 1. Starting with Mojolicious 5.0, X-Forwarded-Proto will be automatically recognized.

<pre>
$ ENV {MOJO_REVERSE_PROXY} = 1;
</ pre>

(Setting this has no effect on the original app.)

<h4> Use hook to rewrite base path via reverse proxy </ h4>

In order to dispatch correctly, I have to tell you that the / gitweblite part is the base path.

<pre>
$ self-> hook ('before_dispatch' => sub {
  my $ self = shift;
  
  if ($ self-> req-> headers-> header ('X-Forwarded-Host')) {
    my $ prefix = shift @ {$ self-> req-> url-> path-> parts};
    push @ {$ self-> req-> url-> base-> path-> parts}, $ prefix;
  }
}
</ pre>

Now the host name and port number will be output correctly with url_for and redirect_to. This statement does not have any adverse effects when running the application standalone in a test environment.

<h3> If you want to create a link to an HTTP page on an SSL page </ h3>

Accessed with httpsIn that case, if you specify the URL with the root relative path (/ app1) in the page, it will be interpreted as the following URL. https://yourhost.com/app1

If you want to link to the HTTP page on the SSL page, you can do as follows.

<pre>
URL: <a href="<%=url_for('/ ​​foo')-> to_abs-> scheme ('http')%> "> Foo </a>
</ pre>

url_for returns a Mojo :: URL object, so convert it to an absolute URL and then convert the schema to http.

<pre>
url_for ('/ foo')-> to_abs-> scheme ('http')
</ pre>

By doing this, you can easily link to http from the SSL page.

<h3> If you want to create a link to an SSL page on an HTTP page </ h3>

If you want to create a link to an SSL page on an HTTP page, you can do the following:

<pre>
URL: <a href="<%=url_for('/ ​​foo')-> to_abs-> scheme ('https')%> "> Foo </a>
</ pre>

url_for returns a Mojo :: URL object, so convert it to an absolute URL and then convert the schema to https.

<pre>
url_for ('/ foo')-> to_abs-> schema ('https')
</ pre>

By doing this, you can create a link to the SSL page.

<h3> Generate SSH URL with url_for method </ h3>

The url_for method can be created not only for HTTP URLs, but for anything that has a URL structure.

Let's create the following SSH URL.

<pre>
ssh: //kimoto@somehost.com: 20000 / foo / bar.git
</ pre>

Do the following:
<pre>
my $ url = url_for ('/foo/bar.git')-> to_abs-> scheme ('ssh')
  -> userinfo ('kimoto')-> host ('somehost.com')-> port (20000);
</ pre>

First, convert it to an absolute URL with the to_abs method, then set the protocol with the schema method, the user name with the userinfo method, the host name with the host method, and the port number with the port method.